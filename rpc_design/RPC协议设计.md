## RPC协议设计

- 协议头
  - 协议长度、序列化方式、协议标识、消息ID、链路ID、消息类型等
  - 支持可扩展的协议头
- 协议体
  - 请求接口方法名、参数值、扩展属性等

![image-20200819012509132](assets/image-20200819012509132.png)

- 序列化协议选择
  - 效率、性能、体积、**通用性和兼容性（重要）**
  - 安全性（安全漏洞）

- 代理
  - Byte Buddy

- 插件架构
  - 面向接口契约
- 注册中心
  - AP
- 健康检测
  - 心跳检测（服务存活情况）+业务可用率（服务质量情况）
- 路由策略
  - 变更服务，降低发生故障的概率
    - 灰度发布
    - 路由策略实现流量隔离
- 负载均衡
  - 自适应负载均衡器
    - 打分器：根据指标收集器收集的指标，计算综合打分
    - 指标收集器：状态（CPU核数、CPU负载、内存），请求耗时（平均耗时、TP99，TP999）
    - 权重计算器：根据指标收集器收集的指标，设置指标权重
    - 随机权重策略：根据权重+分数，计算综合权重。最后根据随机权重策略，选择服务节点
- 异常重试
  - 重试策略
    - 重试计数
    - 指定需要重试的异常（可配置通用的 + 服务特定的业务异常重试策略）
  - 重试导致超时时间失效
    - 重试前先检测超时时间，如果超时了，则抛异常，如果未超时，则重置重试时间，再发起重试
  - 开启重试需对业务做幂等
  - 去除异常节点，再次负载均衡，选择目标节点
- 优雅关闭
  - 注册关闭钩子（ShutdownHook）
    - 开启服务关闭标识，用于拒绝新请求
    - 通知服务下线
    - 等待正在处理的请求结束（请求计数器为0）
    - 释放资源
- 优雅启动
  - 启动预热
  - 延迟暴露
- 熔断限流
  - 熔断
    - 服务调用者自我保护
    - RPC熔断判断逻辑应该在整个链路靠前的位置
  - 限流
    - 服务提供者自我保护
    - 配置中心限流配置：限流量+服务节点数，由每个服务节点自己计算其限流阈值（避免扩容）
- 业务分组（隔离流量）
  - 同一服务供不同业务方调用时，为防止不同调用方互相影响，将同一服务进行分组，是的流量隔离
  - 服务提供方支持分组，主要由注册中心进行区分，服务调用方请求时，同样需要带上所调分组信息
- 链路追踪
  - Trace & Span
  - 调用树
- 异常堆栈
  - 完整的异常堆栈信息
- 时钟轮
  - 定时任务
    - 如PRC调用的超时时间，在每次生成Future时，生成创建时间与超时时间
    - 用一个线程处理所有定时任务：一个线程每隔100毫秒会扫描一遍所有的Future超时任务，当发现一个Future超时，我们就执行这个任务，对这个Future执行超时逻辑（弊端：不停的「额外无用的」扫描，浪费CPU资源）
  - 时钟轮
    - 减少额外的扫描（如果我的一批定时任务是在5秒后执行，那我在4.9秒开始扫描这批定时任务）
    - 算法原理：
      - 借鉴生活中的时钟的秒、分交替逻辑，秒钟转动一周，为一分钟。
      - 时钟轮：秒针或分针跳动的一个周期
      - 时间槽：相当于时钟的刻度，我们将每个任务放到对应的时间槽上
      - 根据时钟轮的时间设置，将任务放到对应层的槽位上，指针转动到一个时间槽上，就去出其任务来执行
- 流量回放
  - 常见的工具有TcpCopy
  - 旁录RPC请求的入、出参数，异步保存
  - 模拟一个RPC调用方，回放请求到待测试的集群（改造后的业务RPC服务），对比返回值
- 动态分组（扩缩容）
  - 修改注册中心同一服务的不同分组的映射关系，实现将服务的组内节点数动态修改

